<!doctypehtml>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Concurrency Nedir?</title>

    <meta name="viewport"content="width=device-width,initial-scale=1">
    <meta http-equiv="X-UA-Compatible"content="ie=edge">

    <link rel="shortcut icon"href="../assets/favicon.ico"type="image/x-icon">
    <link rel="preload"href="../styles/article.css"as="style">
    <link rel="stylesheet"href="../styles/article.css">
    <link rel="preconnect"href="https://fonts.googleapis.com">
    <link rel="preconnect"href="https://fonts.gstatic.com"crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400&display=swap"rel="stylesheet">
  </head>
  <body>
    <header id="top-container"role="navigation">
      <head>
  <script src="https://kit.fontawesome.com/886d3c9542.js"crossorigin="anonymous"></script>
  <nav>
    <a class="info-link"href="/">
      <i class="fa-brands fa-diaspora"></i>
      <h1 style="font-size: 18px">Hasan</h1>
      <span style="font-size: 18px">Yurdakul</span>
    </a>
    <small>
      <a id="home"class="info-link"href="/">ğŸ¡Home</a> |
      <a id="about"class="info-link"href="/about.html">ğŸ‘€About</a> |
      <a id="works"class="info-link"href="/works.html">ğŸ”¥Works</a> |
      <a id="articles"class="info-link"href="/articles.html">ğŸ“šArticles</a>
    </small>
  </nav>
</head>

    </header>
    <main id="main-container">
      <article id="article-container">
        <h1 id="article-title">Concurrency Nedir?</h1>
        
        <h2 id="article-subtitle">Javascriptte concurrency modeli nasÄ±l iÅŸler?</h2>
        
        <time id="article-date"> 2024.02.14 </time>
        <section id="article-content-container"><details><summary>Table of Contents</summary>
<p><div class="table-of-contents"><ul><li><a href="#call-stack%2C-heap-ve-queue">Call Stack, Heap ve Queue</a><li><a href="#concurrency-nedir%3F">Concurrency nedir?</a><li><a href="#concurrency-nas%C4%B1l-%C3%A7al%C4%B1%C5%9F%C4%B1r%3F">Concurrency nasÄ±l Ã§alÄ±ÅŸÄ±r?</a><li><a href="#event-loop">Event Loop</a><li><a href="#callback">Callback</a><li><a href="#promise%E2%80%99ler">Promiseâ€™ler</a><li><a href="#async%2Fawait">Async/await</a><li><a href="#sonu%C3%A7">SonuÃ§</a></ul></div><p></p>
</details>
<p>JavaScript, <strong>single-thread</strong> bir dildir. Bu da, aynÄ± anda sadece bir gÃ¶revi yerine getirebilir anlamÄ±na gelir. Bu threadler event-basedâ€™tir ve yalnÄ±zca eventâ€™larÄ±n gerÃ§ekleÅŸmesiyle triggerlanÄ±rlar.</p>
<p>Genellikle, bir programÄ±n diÄŸer bÃ¶lÃ¼mleri bozmadan normal akÄ±ÅŸÄ±nÄ±n dÄ±ÅŸÄ±nda Ã§alÄ±ÅŸmasÄ±, daha iyi bir uygulama performansÄ± saÄŸlamak iÃ§in gereklidir. Ancak, JavaScript dili, aynÄ± anda birden fazla ifadenin yÃ¼rÃ¼tÃ¼lmesine izin verecek ÅŸekilde tasarlanmamÄ±ÅŸtÄ±r. Ä°fadeler birbirini takip ederek Ã§alÄ±ÅŸÄ±r. Peki JavaScript birbirini bloklamayan gÃ¶revleri, diÄŸer ifadeleri etkilemeden nasÄ±l gerÃ§ekleÅŸtiriyor?</p>
<h2 id="call-stack%2C-heap-ve-queue"tabindex="-1">Call Stack, Heap ve Queue</h2>
<p>JavaScript single-thread bir dil olmasÄ±na raÄŸmen, tarayÄ±cÄ± karmaÅŸÄ±k iÅŸlemler gerÃ§ekleÅŸtirmek iÃ§in yeterince gÃ¼Ã§lÃ¼dÃ¼r. Call stackler, heapler ve queuelar, tarayÄ±cÄ±nÄ±n bu iÅŸlemleri gerÃ§ekleÅŸtirmesine izin veren birer parÃ§asÄ±dÄ±r.</p>
<p><strong>Heap:</strong> Kodumuzda tanÄ±mlanan nesnelerin ve deÄŸiÅŸkenlerin depolandÄ±ÄŸÄ± yer veya bellek. TarayÄ±cÄ± iÃ§indeki deÄŸiÅŸkenlere ve nesnelere bellek burada tahsis edilir.</p>
<p><strong>Callback queue</strong>: KodlarÄ±n yÃ¼rÃ¼tÃ¼lmeden Ã¶nce sÄ±raya konulduÄŸu ve depolandÄ±ÄŸÄ± yerdir. Queue, first-in, first-out (FIFO) prensibine gÃ¶re Ã§alÄ±ÅŸÄ±r.</p>
<p><strong>Call Stack:</strong> Call stack, function callâ€™larÄ± tutar. ProgramÄ±n yÃ¼rÃ¼tÃ¼lmesi sÄ±rasÄ±nda her fonksiyon stackin en Ã¼stÃ¼ne eklenir ve tamamlandÄ±ktan sonra Ã§Ä±karÄ±lÄ±r. ProgramÄ±n yÃ¼rÃ¼tÃ¼lmesi sÄ±rasÄ±nda Ã§aÄŸrÄ±lan fonksiyonlarÄ± kaydeden basit bir veri yapÄ±sÄ±dÄ±r.</p>
<p>Her fonksiyon, expressionlarÄ± ve statementlarÄ± iÃ§eren bir stack frame oluÅŸturur ve ardÄ±ndan stacke eklenir. Bir deÄŸer return edildiÄŸinde, stackten Ã§Ä±karÄ±lÄ±r.</p>
<p>Birbiri iÃ§erisinde nested ÅŸekilde bulunan tÃ¼m fonksiyonlar iÃ§in stack frame oluÅŸturulur. Stack iÃ§erisindeki Ã¶ÄŸeler genellikle, first-in, last-out (FILO) ÅŸeklinde sÄ±ralanÄ±r.</p>
<h2 id="concurrency-nedir%3F"tabindex="-1">Concurrency nedir?</h2>
<p>Concurrency, aynÄ± anda birden fazla hesaplamanÄ±n gerÃ§ekleÅŸmesine izin verir. AynÄ± anda birden fazla gÃ¶revin gerÃ§ekleÅŸtirilme fikrini aÃ§Ä±klamak iÃ§in kullanÄ±lÄ±r. <strong>Parallelism</strong> ile karÄ±ÅŸtÄ±rÄ±lmamalÄ±dÄ±r.</p>
<p>Concurrency, farklÄ± hedeflere sahip farklÄ± gÃ¶revleri aynÄ± anda gerÃ§ekleÅŸtirme kavramÄ±nÄ± ifade ederken, parallelism, programÄ±n Ã§eÅŸitli bÃ¶lÃ¼mlerinin aynÄ± anda bir gÃ¶revi gerÃ§ekleÅŸtirmesini iÃ§erir.</p>
<ul>
<li><strong>Parallelism</strong>, programlarÄ±n daha hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlamak iÃ§in kullanÄ±lan bir computation tÃ¼rÃ¼dÃ¼r. Bu programlama yaklaÅŸÄ±mÄ±nda, iÅŸlemler paralel olarak yÃ¼rÃ¼tÃ¼lÃ¼r. Programlar kÃ¼Ã§Ã¼k tasklere bÃ¶lÃ¼nÃ¼r ve aynÄ± hedefe ulaÅŸmak iÃ§in aynÄ± anda gerÃ§ekleÅŸtirilirler.</li>
<li><strong>Multi-threading</strong>, aynÄ± kaynaÄŸÄ± paylaÅŸÄ±rken baÄŸÄ±msÄ±z olarak iki veya daha fazla talimatÄ±n yÃ¼rÃ¼tÃ¼ldÃ¼ÄŸÃ¼ bir programlama tekniÄŸidir. JavaScript, tasarÄ±m gereÄŸi multi-thread bir dil deÄŸildir, ancak modern web workerlarÄ±n kullanÄ±mÄ± ile mutl-threading elde edilebilir.</li>
</ul>
<h2 id="concurrency-nas%C4%B1l-%C3%A7al%C4%B1%C5%9F%C4%B1r%3F"tabindex="-1">Concurrency nasÄ±l Ã§alÄ±ÅŸÄ±r?</h2>
<p>JavaScriptâ€™in concurrency modeli, kodu eÅŸzamanlÄ± olarak yÃ¼rÃ¼ten event loopâ€™una dayanÄ±r. JavaScript, varsayÄ±lan olarak, event looplar, call backler, promiseler veya async/await kullanarak asenkron bir programlama modeliyle concurrency oluÅŸturur. Rust ve Go gibi bazÄ± diller, concurrent tasklerin yÃ¼rÃ¼tÃ¼lmesi sÄ±rasÄ±nda basitlik ve performans sunarlar. Ancak, JavaScript concurrency iÃ§in tasarlanmamÄ±ÅŸtÄ±r, buna raÄŸmen JavaScript event-loop ile server ve client sided olarak concurrent Ã§alÄ±ÅŸabilir.</p>
<h2 id="event-loop"tabindex="-1">Event Loop</h2>
<p>Event loop, fonksiyonlarÄ± asenkron olarak yÃ¼rÃ¼tmek iÃ§in JavaScript tarafÄ±ndan benimsenen modeldir. Queueâ€™ya alÄ±nan gÃ¶revleri yÃ¼rÃ¼tmekten sorumludur ve JavaScriptâ€™in multi-thread gÃ¶revleri gerÃ§ekleÅŸtirebilme yeteneÄŸinin arkasÄ±ndaki sÄ±rdÄ±r.</p>
<p>JavaScript, bir betik yÃ¼rÃ¼tmesini en Ã¼stten baÅŸlatÄ±r ve son satÄ±ra kadar devam eder. Genellikle yÃ¼rÃ¼tÃ¼lecek iÅŸlevler callback queueâ€™da saklanÄ±r.</p>
<p>Event loop sÃ¼rekli olarak hem callback queueâ€™yu hem de call stackâ€™i izler. Call stackâ€™in boÅŸ olup olmadÄ±ÄŸÄ±nÄ± kontrol eder ve callback queueâ€™daki bir sonraki Ã¶ÄŸeyi call stackâ€™e pushlar. Call stack boÅŸ deÄŸilse event loop hiÃ§bir ÅŸey yapmaz. Call stack boÅŸ olana kadar bekler ve callback queueâ€™daki bir sonraki iÅŸlevi call stackâ€™e pushlar.</p>
<p>AÅŸaÄŸÄ±daki resim JavaScript runtimeâ€™Ä±nÄ±, Web APIâ€™yi, call stackâ€™i ve event loopâ€™u gÃ¶stermektedir:</p>
<p><img src="/images/concurrency.png"alt="image"loading="lazy"decoding="async"width="1146"height="762"></p>
<p>Event loop sÃ¼rekli olarak callback queueâ€™dan fonksiyonlarÄ± alÄ±r ve call stack boÅŸaldÄ±ÄŸÄ±nda bunlarÄ± call stackâ€™e iter. Call stackâ€™teki gÃ¶rev tamamlandÄ±ktan sonra, event loop callback queueâ€™daki bir sonraki Ã¶ÄŸeyi alÄ±r ve iÅŸlemeye baÅŸlamak iÃ§in call stackâ€™e gÃ¶nderir. Bu, olay dÃ¶ngÃ¼sÃ¼nÃ¼n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ±n temel prensibidir.</p>
<h2 id="callback"tabindex="-1">Callback</h2>
<p>Node.js, hÄ±zlÄ± I/O iÅŸlemlerini gerÃ§ekleÅŸtirmek iÃ§in callbackâ€™leri yoÄŸun bir ÅŸekilde kullanÄ±r. Callbackler, baÅŸka bir fonksiyonun argÃ¼manÄ± olarak geÃ§en iÅŸlevlerdir. JavaScriptâ€™te callbackler, uygulamalarÄ±n beklenmedik donmasÄ±nÄ± azaltmak iÃ§in kullanÄ±lÄ±r.</p>
<p>Bir callback fonksiyonu, kendisini bir argÃ¼man olarak alan dÄ±ÅŸtaki fonksiyonun tamamlanmasÄ±ndan sonra yÃ¼rÃ¼tÃ¼lÃ¼r. BaÅŸka bir fonksiyonun tamamlanmasÄ±nÄ±n hemen ardÄ±ndan bir fonksiyonu Ã§alÄ±ÅŸtÄ±rmak iÃ§in kullanÄ±lÄ±r. setTimeout() yÃ¶ntemi, baÅŸka bir iÅŸlevi argÃ¼man olarak alan bir iÅŸlevin bir Ã¶rneÄŸidir. Ä°ÅŸte bir Ã¶rnek:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> greeting = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello there&quot;</span>);
};
<span class="hljs-built_in">setTimeout</span>(greeting, <span class="hljs-number">3000</span>);
</code></pre>
<p>Callback fonksiyonu (greeting), setTimeout() metoduna bir argÃ¼man olarak iletilir ve setTimeout() iÅŸlemini tamamladÄ±ktan sonra 3 saniye bekler ve hemen sonra yÃ¼rÃ¼tÃ¼lÃ¼r.</p>
<p>Callback fonksiyonlarÄ±, JavaScriptâ€™in kodlarÄ± asenkron olarak yÃ¼rÃ¼tmesine izin verir. setTimeout() fonksiyonu yÃ¼rÃ¼tÃ¼lÃ¼rken, diÄŸer ifadeler eÅŸ zamanlÄ± olarak yÃ¼rÃ¼tÃ¼lebilir. Bu yÃ¶ntemi kullanarak, JavaScript concurrent Ã§alÄ±ÅŸabilir ve birden fazla ifadeyi aynÄ± anda yÃ¼rÃ¼tebilir.</p>
<h2 id="promise%E2%80%99ler"tabindex="-1">Promiseâ€™ler</h2>
<p>Promiseâ€™ler, JavaScriptâ€™te asenkron gÃ¶revleri ele almak iÃ§in kullanÄ±labilecekleri anlamÄ±nda callbackâ€™lere benzerler. Promiseâ€™lerin benimsenmesinden Ã¶nce, gÃ¶revleri asenkron olarak ele almak iÃ§in callback fonksiyonlarÄ± kullanÄ±lÄ±rdÄ±. Ancak, Ã§oklu nested callback fonksiyonlarÄ±nÄ± ele almak bir sorun haline geldi ve bu da programa gereksiz karmaÅŸÄ±klÄ±k ekledi. Promiseâ€™ler, nested callbackâ€™leri ele almanÄ±n ideal yolu haline geldi.</p>
<p>Bir promise, bir asenkron iÅŸlemden sonra bir deÄŸer Ã¼reten bir nesnedir. Asenkron iÅŸlemin baÅŸarÄ±lÄ± olup olmadÄ±ÄŸÄ±nÄ± belirlemek iÃ§in iyi bir yoldur. Bir promise kullanÄ±mÄ±na dair Ã¶rnek aÅŸaÄŸÄ±da verilmiÅŸtir:</p>
<pre class="hljs"><code>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) {
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;done&quot;</span>)
    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;error&quot;</span>)
}

  promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)
})
</code></pre>
<p>Bir promise, resolved ve rejected promiseâ€™leri bitirmek iÃ§in <em>.then</em> ve <em>.catch</em> yÃ¶ntemlerini kullanÄ±r.</p>
<p>Promisler asenkron olarak Ã§alÄ±ÅŸtÄ±ÄŸÄ±ndan, yukarÄ±daki kodda olduÄŸu gibi iÅŸlevlerin iÅŸlemi promiseâ€™Ä±n sonucuna baÄŸlÄ± olan fonksiyonlar <em>.then</em> yÃ¶ntemi iÃ§ine yerleÅŸtirilmelidir. Bu ÅŸekildeki kodlar yalnÄ±zca promise alÄ±ndÄ±ÄŸÄ±nda Ã§alÄ±ÅŸÄ±r.</p>
<h2 id="async%2Fawait"tabindex="-1">Async/await</h2>
<p>Promisleri kullanmak ve zincirlemek karmaÅŸÄ±k ve anlaÅŸÄ±lmasÄ± zor olabilir, bu sorunu Ã§Ã¶zmek iÃ§in async/await ortaya Ã§Ä±ktÄ±. Asenkron kodlarÄ± verimli bir ÅŸekilde Ã§alÄ±ÅŸtÄ±rmak ve tanÄ±mlamak iÃ§in async/await kullanÄ±lÄ±r.</p>
<p><strong>async</strong> anahtar kelimesi, bir iÅŸlevin asenkron olduÄŸunu tanÄ±mlamak iÃ§in bir iÅŸlevin Ã¶nÃ¼ne yerleÅŸtirilir ve iÅŸlevin her zaman bir promise dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nden emin olur.</p>
<p><strong>await</strong> anahtar kelimesi, bir promise dÃ¶nene kadar iÅŸlevi geciktirir. Bir fonksiyon, bir promise alÄ±nana kadar yÃ¼rÃ¼tmesini tamamlamaz. await anahtar kelimesi, bir async iÅŸlevi dÄ±ÅŸÄ±nda kullanÄ±lamaz.</p>
<p>Ã–rnek bir async/await kodu:</p>
<pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">await</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Welcome Back!&quot;</span>)
    }, <span class="hljs-number">2000</span>)
}

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello&quot;</span>)
</code></pre>
<p>Asenkron fonksiyonlarÄ±n iÅŸlenmesi zaman alabilir ve diÄŸer gÃ¶revlerin yÃ¼rÃ¼tÃ¼lmesini engellemeden arka planda eÅŸzamanlÄ± olarak Ã§alÄ±ÅŸabilir.</p>
<p>JavaScriptâ€™teki asenkron iÅŸlevler async anahtar kelimesi ile tanÄ±mlanÄ±r. Bu, JavaScriptâ€™e iÅŸlevin yÃ¼rÃ¼tmesini bitirmesinin zaman alacaÄŸÄ±nÄ± ve yÃ¼rÃ¼tÃ¼lÃ¼rken diÄŸer gÃ¶revlere devam edebileceÄŸini sÃ¶yler.</p>
<p>Bu, JavaScriptâ€™in, asenkron iÅŸlevden bir yanÄ±t almadan Ã¶nce async iÅŸlevinin dÄ±ÅŸÄ±ndaki diÄŸer iÅŸlemleri Ã§alÄ±ÅŸtÄ±rmasÄ±na olanak tanÄ±r. await anahtar kelimesi, iÅŸlevin yÃ¼rÃ¼tmesini tamamlamasÄ± zaman alan kÄ±smÄ±nÄ± tanÄ±mlar. YukarÄ±daki kodun sonucu ÅŸudur:</p>
<pre class="hljs"><code><span class="hljs-title class_">Hello</span>
<span class="hljs-title class_">Welcome</span> <span class="hljs-title class_">Back</span>!
</code></pre>
<p>GÃ¶rebileceÄŸiniz gibi, â€œHelloâ€ mesajÄ± â€œWelcome Back!â€ mesajÄ±ndan Ã¶nce gÃ¶rÃ¼ntÃ¼leniyor. Bu, asenkron fonksiyonun arka planda Ã§alÄ±ÅŸtÄ±ÄŸÄ± ve &quot;Welcome Back&quot;i gÃ¶rÃ¼ntÃ¼lemek iÃ§in yaklaÅŸÄ±k iki saniye beklediÄŸi Ã§in olur. JavaScript async fonksiyonu arkaplanda Ã§alÄ±ÅŸtÄ±rÄ±rken, async fonksiyondan bir sonuÃ§ beklemeden diÄŸer ifadeleri Ã§alÄ±ÅŸtÄ±rmaya devam eder.</p>
<p>Bu, JavaScriptâ€™in gÃ¶revleri gerÃ§ekleÅŸtirip, ifadeleri concurrent olarak Ã§alÄ±ÅŸtÄ±rabilmesinin bir Ã¶rneÄŸidir.</p>
<p>Callbackâ€™ler, promiseâ€™ler ve async/await, gÃ¶revleri event loop ve tarayÄ±cÄ±nÄ±n Web APIâ€™leri yardÄ±mÄ±yla concurrent olarak Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ± saÄŸlayan JavaScript Ã¶zellikleridir.</p>
<h2 id="sonu%C3%A7"tabindex="-1">SonuÃ§</h2>
<p>Veri iÅŸleme sÄ±rasÄ±nda sequential kod yÃ¼rÃ¼tÃ¼lmesi nedeniyle birÃ§ok sorunla karÅŸÄ±laÅŸÄ±lÄ±r. Verilerin iÅŸlenmesinin ne kadar sÃ¼receÄŸini bilmek zordur. Sequentail bir kod, diÄŸer tÃ¼m kodlarÄ± engeller ve uygulamanÄ±n daha fazla yÃ¼rÃ¼tÃ¼lmesini engeller.</p>
<p>Concurrent kod, sequential kodun engelleme sorununu ortadan kaldÄ±rÄ±r ve birden Ã§ok kullanÄ±cÄ± isteÄŸini veya olayÄ±nÄ± herhangi bir sorun olmadan aynÄ± anda iÅŸleyebilir.</p>
<p>JavaScript, varsayÄ±lan olarak single-threaded bir programlama dilidir ve kodunu sequential olarak Ã§alÄ±ÅŸtÄ±rÄ±r. Ancak, JavaScript, CPU aÄŸÄ±rlÄ±klÄ± uygulamalar oluÅŸtururken en iyi seÃ§enek deÄŸildir Ã§Ã¼nkÃ¼ JavaScript hala single-threaded bir dildir ve tek bir iÅŸlemci Ã§ekirdeÄŸinde tek bir iÅŸlem Ã§alÄ±ÅŸtÄ±rabilir.</p>
<p>CPU aÄŸÄ±rlÄ±klÄ± uygulamalar geliÅŸtirilirken CPU intensive gÃ¶revleri ele alabilen diÄŸer diller tercih edilmelidir.</p>
</section>
        <section id="article-navigation">
           
        </section>
        <section id="article-list-button-container">
          <a href="/articles.html">
            <div id="article-list-button">ğŸ“š</div>
          </a>
        </section>
      </article>
    </main>
  

